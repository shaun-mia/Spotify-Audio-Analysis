# -*- coding: utf-8 -*-
"""Spotify Audio Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hKzUkOUiILvzvQEOs7DcnAfxnND-2KmO

# Spotify Audio Analysis



## Project Introduction <a class="anchor" id="intro"></a>

#### About Spotify:
Founded in 2006, [Spotify](https://open.spotify.com/) has grown into a global leader in music streaming, offering access to millions of songs, podcasts, and other audio content. Through cutting-edge technology and advanced data analytics, Spotify provides personalized listening experiences to users, supporting both a free, ad-based model and a premium subscription service.

#### Industry Scope:
Spotify operates within the realms of music streaming, podcasting, audio content, technology, and advertising, positioning itself as a pivotal player in the digital audio space.

#### Purpose of the Analysis:
The goal of this analysis is to uncover key insights from Spotify’s extensive audio data, identifying patterns that contribute to a track's popularity. By examining features like danceability, energy, acousticness, and valence, this project aims to determine which elements make songs resonate with listeners and how these attributes vary across different genres and time frames.

#### Dataset Overview:
For this project, we utilize two robust datasets:

1. **tracks.csv** from [Spotify Datasets](https://www.kaggle.com/datasets/lehaknarnauli/spotify-datasets), containing 586,672 entries. This dataset includes:
    * **Track Details:** Track ID, song title, popularity score, duration, explicit content flag, and artist information.
    * **Audio Features:** Danceability, energy, loudness, speechiness, acousticness, instrumentalness, valence, and tempo.
    * **Additional Attributes:** Release date, key, mode, and time signature.

2. **SpotifyFeatures.csv** from [Spotify Tracks DB](https://www.kaggle.com/datasets/zaheenhamidani/ultimate-spotify-tracks-db), comprising 232,725 entries. This dataset includes:
    * **Genre Information:** Genre classification for each track.
    * **Artist and Track Data:** Artist name, track title, and track ID.
    * **Audio Features:** Acousticness, danceability, energy, liveness, loudness, speechiness, valence, and tempo.
    * **Additional Attributes:** Key, mode, duration, and time signature.

Using these datasets, this analysis delves into how audio characteristics influence track popularity, providing insights into listener preferences across different genres and time periods.

# 1: Import Libraries and Load Data

**Import Libraries**
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Set plot style
sns.set_style("whitegrid")

"""**Data Load**"""

from google.colab import drive
drive.mount('/content/drive')

# Load data from Google Drive
df_tracks = pd.read_csv('/content/drive/MyDrive/Data Analysis/Python Project/Spotify Music Analysis/Tracks.csv')
df_genre = pd.read_csv('/content/drive/MyDrive/Data Analysis/Python Project/Spotify Music Analysis/SpotifyFeatures.csv')

"""# 2. Data Overview

**Preview Data Structure**
"""

# Display the first rows of each dataset
print("Tracks.csv Preview:")
df_tracks.head()

print("SpotifyFeatures.csv Preview:")
df_genre.head()

"""**Summary Information on Each Dataset**"""

# Summary information of datasets
print("Tracks.csv Info:")
print(df_tracks.info())

print("SpotifyFeatures.csv Info:")
print(df_genre.info())

"""# 3. Data Cleaning

**Handle Missing Values**
"""

# Drop rows with missing 'name' or 'track_name'
df_tracks.dropna(subset=['name'], inplace=True)
df_genre.dropna(subset=['track_name'], inplace=True)

"""**Convert Data Types**"""

# Convert release date columns to datetime
df_tracks['release_date'] = pd.to_datetime(df_tracks['release_date'], errors='coerce')

# Convert 'mode' to binary (0 for Minor, 1 for Major)
df_genre['mode_binary'] = df_genre['mode'].map({'Minor': 0, 'Major': 1})

"""**Convert Duration from Milliseconds to Seconds**"""

# Convert duration from milliseconds to seconds
df_tracks['duration'] = df_tracks['duration_ms'] / 1000
df_genre['duration'] = df_genre['duration_ms'] / 1000

# Drop original duration columns
df_tracks.drop('duration_ms', axis=1, inplace=True)
df_genre.drop('duration_ms', axis=1, inplace=True)

"""# Exploratory Data Analysis (EDA)

**Summary Statistics**
"""

print("Summary Statistics for Tracks.csv:")
df_genre.describe()

print("Summary Statistics for SpotifyFeatures.csv:")
df_tracks.describe()

"""# Key EDA Visualizations

** Distribution of Track Popularity **
"""

plt.figure(figsize=(12, 6))
sns.histplot(df_tracks['popularity'], bins=30, kde=True)
plt.title('Distribution of Track Popularity')
plt.xlabel('Popularity')
plt.ylabel('Frequency')
plt.show()

"""**Distribution of Danceability**"""

plt.figure(figsize=(12, 6))
sns.histplot(df_tracks['danceability'], bins=30, kde=True, color='orange')
plt.title('Distribution of Danceability')
plt.xlabel('Danceability')
plt.ylabel('Frequency')
plt.show()

"""**Correlation Heatmap**"""

numeric_df = df_tracks.select_dtypes(include=[np.number])
plt.figure(figsize=(14, 12))
sns.heatmap(numeric_df.corr(), annot=True, fmt='.2f', cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

"""**Number of Songs per Year**"""

# Count the number of songs per year
songs_per_year = df_tracks['year'].value_counts().sort_index()

# Plotting the number of songs per year
plt.figure(figsize=(12, 6))
songs_per_year.plot(kind='bar', color='skyblue')
plt.title('Number of Songs per Year')
plt.xlabel('Year')
plt.ylabel('Number of Songs')
plt.xticks(rotation=45)
plt.show()

"""**Year vs. Duration**"""

# Calculate the average duration of songs per year
avg_duration_per_year = df_tracks.groupby('year')['duration'].mean()

# Plotting the average duration of songs per year
plt.figure(figsize=(12, 6))
sns.lineplot(x=avg_duration_per_year.index, y=avg_duration_per_year.values, marker='o')
plt.title('Average Song Duration Over the Years')
plt.xlabel('Year')
plt.ylabel('Average Duration (seconds)')
plt.xticks(rotation=45)
plt.show()

"""**Duration of Songs in Different Genres**"""

# Calculate the average duration of songs by genre
avg_duration_by_genre = df_genre.groupby('genre')['duration'].mean().sort_values()

# Plotting the average duration of songs by genre
plt.figure(figsize=(12, 6))
avg_duration_by_genre.plot(kind='barh', color='lightgreen')
plt.title('Average Duration of Songs by Genre')
plt.xlabel('Average Duration (seconds)')
plt.ylabel('Genre')
plt.show()

"""# Genre Popularity Analysis

**Top Genres by Popularity**
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Sample DataFrame definition (if you haven't defined df_genre)
# Uncomment and modify as needed
# data = {
#     'genre': ['Pop', 'Rock', 'Hip-Hop', 'Jazz', 'Classical', 'Electronic'],
#     'popularity': [75, 80, 90, 70, 60, 85]
# }
# df_genre = pd.DataFrame(data)

# Calculate the top 5 genres by average popularity
top_genres = df_genre.groupby('genre')['popularity'].mean().sort_values(ascending=False).head(5)

# Create a horizontal bar chart
plt.figure(figsize=(10, 6))
colors = plt.cm.viridis(np.linspace(0, 1, len(top_genres)))  # Generate different colors

# Plot the horizontal bar chart
top_genres.plot(kind='barh', color=colors)

# Set the title and labels
plt.title("Top 5 Genres by Popularity")
plt.xlabel("Popularity")
plt.ylabel("Genre")

# Add data labels on top of the bars
for index, value in enumerate(top_genres):
    plt.text(value, index, f'{value:.2f}', ha='left', va='center')

# Show the plot
plt.show()

"""**Average Audio Features by Top Genres**"""

top_genres_list = ['Pop', 'Dance', 'Rap', 'Reggaeton', 'Hip-Hop']
filtered_df = df_genre[df_genre['genre'].isin(top_genres_list)]
genre_audio_features = filtered_df.groupby('genre').agg({
    'danceability': 'mean',
    'energy': 'mean',
    'loudness': 'mean',
    'acousticness': 'mean',
    'valence': 'mean',
    'duration': 'mean'
}).reset_index()

# Create bar plots for each audio feature
plt.figure(figsize=(15, 10))
for i, feature in enumerate(['danceability', 'energy', 'loudness', 'acousticness', 'valence', 'duration']):
    plt.subplot(2, 3, i + 1)
    sns.barplot(data=genre_audio_features, x='genre', y=feature, palette='coolwarm')
    plt.title(f'Average {feature.capitalize()} by Genre')
    plt.xlabel('Genre')
    plt.ylabel(f'{feature.capitalize()}')
plt.tight_layout()
plt.show()

"""**Average Audio Features by Bottom Genres**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Sample DataFrame definition (if you haven't defined df_genre)
# Uncomment and modify as needed
# data = {
#     'genre': ['Pop', 'Dance', 'Rap', 'Reggaeton', 'Hip-Hop', 'Rock', 'Jazz', 'Classical', 'Country', 'Folk'],
#     'popularity': [75, 80, 90, 70, 60, 30, 20, 15, 25, 10],
#     'danceability': np.random.rand(10),
#     'energy': np.random.rand(10),
#     'loudness': np.random.rand(10) * 100 - 50,
#     'acousticness': np.random.rand(10),
#     'valence': np.random.rand(10),
#     'duration': np.random.randint(180000, 300000, size=10)  # Duration in milliseconds
# }
# df_genre = pd.DataFrame(data)

# Identify the bottom 5 genres by average popularity
bottom_genres = df_genre.groupby('genre')['popularity'].mean().sort_values(ascending=True).head(5)

# Filter the original DataFrame for these bottom genres
filtered_bottom_df = df_genre[df_genre['genre'].isin(bottom_genres.index)]

# Calculate average audio features for the bottom genres
bottom_genre_audio_features = filtered_bottom_df.groupby('genre').agg({
    'danceability': 'mean',
    'energy': 'mean',
    'loudness': 'mean',
    'acousticness': 'mean',
    'valence': 'mean',
    'duration': 'mean'
}).reset_index()

# Create bar plots for each audio feature
plt.figure(figsize=(15, 10))
for i, feature in enumerate(['danceability', 'energy', 'loudness', 'acousticness', 'valence', 'duration']):
    plt.subplot(2, 3, i + 1)
    sns.barplot(data=bottom_genre_audio_features, x='genre', y=feature, palette='coolwarm')
    plt.title(f'Average {feature.capitalize()} by Genre')
    plt.xlabel('Genre')
    plt.ylabel(f'{feature.capitalize()}')
plt.tight_layout()
plt.suptitle("Average Audio Features for Bottom 5 Genres", y=1.05)  # Adjust title position
plt.show()

"""**Most Frequent Aritist**"""

# Display the columns of the df_tracks DataFrame
print(df_tracks.columns)

# Plotting the most frequent artists
plt.figure(figsize=(12, 6))
sns.barplot(x=most_frequent_artists.values, y=most_frequent_artists.index, palette='viridis')
plt.title("Top 10 Most Frequent Artists")
plt.xlabel("Number of Tracks")
plt.ylabel("Artist Name")
plt.show()

"""**Time-Based Analysis**"""

# Set release_date as the index and ensure datetime format
df_tracks.set_index('release_date', inplace=True)

# Extract year from the release_date
df_tracks['year'] = df_tracks.index.year

"""# Visualize Trends Over Time

**Average Song Duration Over Time**
"""

# Calculate average duration per year
avg_duration_per_year = df_tracks.groupby('year')['duration'].mean()

# Plotting average duration per year
plt.figure(figsize=(10, 5))
sns.lineplot(x=avg_duration_per_year.index, y=avg_duration_per_year.values)
plt.title("Average Song Duration Over Time")
plt.xlabel("Year")
plt.ylabel("Duration (seconds)")
plt.show()

"""**Average Popularity Over Time**"""

# Calculate average popularity per year
avg_popularity_per_year = df_tracks.groupby('year')['popularity'].mean()

# Plotting average popularity per year
plt.figure(figsize=(10, 5))
sns.lineplot(x=avg_popularity_per_year.index, y=avg_popularity_per_year.values)
plt.title("Average Song Popularity Over Time")
plt.xlabel("Year")
plt.ylabel("Popularity")
plt.show()

"""**Average Danceability Over Time**"""

# Calculate average danceability per year
avg_danceability_per_year = df_tracks.groupby('year')['danceability'].mean()

# Plotting average danceability per year
plt.figure(figsize=(10, 5))
sns.lineplot(x=avg_danceability_per_year.index, y=avg_danceability_per_year.values)
plt.title("Average Danceability Over Time")
plt.xlabel("Year")
plt.ylabel("Danceability")
plt.show()

"""### **Conclusions**

This comprehensive analysis of Spotify's audio data reveals significant trends and patterns that highlight the evolving nature of music consumption. Here are the key takeaways:

- **Popularity Trends**: The upward trajectory of average track popularity over the years indicates a growing engagement with Spotify’s offerings, suggesting that the platform's music selection is resonating increasingly well with listeners. This trend emphasizes the importance of continuously updating and diversifying music catalogs to cater to user preferences.

- **Evolution of Musical Characteristics**: The increase in average song duration and danceability in recent years suggests a shift towards more upbeat and rhythm-driven tracks. This could reflect listeners' preferences for music that enhances social experiences, such as dancing and gatherings. The data implies that music creators may be responding to these trends, potentially impacting the styles and formats of new releases.

- **Genre-Specific Insights**: Analysis of genre dynamics reveals that popular genres are characterized by high energy and loudness, while genres such as classical tend to have longer durations and lower energy levels. This distinction is crucial for understanding listener preferences and can guide playlist curation and recommendation systems, ensuring that users receive tailored music experiences that align with their tastes.

- **Implications for Music Recommendation Systems**: The insights gained from this analysis can inform the development of more sophisticated music recommendation algorithms. By leveraging patterns in popularity, duration, and genre characteristics, platforms can enhance user satisfaction and retention, ultimately leading to a more engaged audience.

In summary, this analysis not only uncovers trends within Spotify’s catalog but also provides actionable insights for music producers, marketers, and platform developers. By understanding user preferences and the characteristics of popular music, stakeholders can make informed decisions that enhance the overall music experience on the platform.
"""